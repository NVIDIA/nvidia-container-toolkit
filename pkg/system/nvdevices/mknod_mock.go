// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package nvdevices

import (
	"sync"
)

// Ensure, that mknoderMock does implement mknoder.
// If this is not the case, regenerate this file with moq.
var _ mknoder = &mknoderMock{}

// mknoderMock is a mock implementation of mknoder.
//
//	func TestSomethingThatUsesmknoder(t *testing.T) {
//
//		// make and configure a mocked mknoder
//		mockedmknoder := &mknoderMock{
//			MknodeFunc: func(s string, n1 int, n2 int) error {
//				panic("mock out the Mknode method")
//			},
//		}
//
//		// use mockedmknoder in code that requires mknoder
//		// and then make assertions.
//
//	}
type mknoderMock struct {
	// MknodeFunc mocks the Mknode method.
	MknodeFunc func(s string, n1 int, n2 int) error

	// calls tracks calls to the methods.
	calls struct {
		// Mknode holds details about calls to the Mknode method.
		Mknode []struct {
			// S is the s argument value.
			S string
			// N1 is the n1 argument value.
			N1 int
			// N2 is the n2 argument value.
			N2 int
		}
	}
	lockMknode sync.RWMutex
}

// Mknode calls MknodeFunc.
func (mock *mknoderMock) Mknode(s string, n1 int, n2 int) error {
	callInfo := struct {
		S  string
		N1 int
		N2 int
	}{
		S:  s,
		N1: n1,
		N2: n2,
	}
	mock.lockMknode.Lock()
	mock.calls.Mknode = append(mock.calls.Mknode, callInfo)
	mock.lockMknode.Unlock()
	if mock.MknodeFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.MknodeFunc(s, n1, n2)
}

// MknodeCalls gets all the calls that were made to Mknode.
// Check the length with:
//
//	len(mockedmknoder.MknodeCalls())
func (mock *mknoderMock) MknodeCalls() []struct {
	S  string
	N1 int
	N2 int
} {
	var calls []struct {
		S  string
		N1 int
		N2 int
	}
	mock.lockMknode.RLock()
	calls = mock.calls.Mknode
	mock.lockMknode.RUnlock()
	return calls
}
