// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package installer

import (
	"io"
	"os"
	"sync"
)

// Ensure, that fileInstallerMock does implement fileInstaller.
// If this is not the case, regenerate this file with moq.
var _ fileInstaller = &fileInstallerMock{}

// fileInstallerMock is a mock implementation of fileInstaller.
//
//	func TestSomethingThatUsesfileInstaller(t *testing.T) {
//
//		// make and configure a mocked fileInstaller
//		mockedfileInstaller := &fileInstallerMock{
//			installContentFunc: func(reader io.Reader, s string, v os.FileMode) error {
//				panic("mock out the installContent method")
//			},
//			installFileFunc: func(s1 string, s2 string) (os.FileMode, error) {
//				panic("mock out the installFile method")
//			},
//			installSymlinkFunc: func(s1 string, s2 string) error {
//				panic("mock out the installSymlink method")
//			},
//		}
//
//		// use mockedfileInstaller in code that requires fileInstaller
//		// and then make assertions.
//
//	}
type fileInstallerMock struct {
	// installContentFunc mocks the installContent method.
	installContentFunc func(reader io.Reader, s string, v os.FileMode) error

	// installFileFunc mocks the installFile method.
	installFileFunc func(s1 string, s2 string) (os.FileMode, error)

	// installSymlinkFunc mocks the installSymlink method.
	installSymlinkFunc func(s1 string, s2 string) error

	// calls tracks calls to the methods.
	calls struct {
		// installContent holds details about calls to the installContent method.
		installContent []struct {
			// Reader is the reader argument value.
			Reader io.Reader
			// S is the s argument value.
			S string
			// V is the v argument value.
			V os.FileMode
		}
		// installFile holds details about calls to the installFile method.
		installFile []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
		// installSymlink holds details about calls to the installSymlink method.
		installSymlink []struct {
			// S1 is the s1 argument value.
			S1 string
			// S2 is the s2 argument value.
			S2 string
		}
	}
	lockinstallContent sync.RWMutex
	lockinstallFile    sync.RWMutex
	lockinstallSymlink sync.RWMutex
}

// installContent calls installContentFunc.
func (mock *fileInstallerMock) installContent(reader io.Reader, s string, v os.FileMode) error {
	if mock.installContentFunc == nil {
		panic("fileInstallerMock.installContentFunc: method is nil but fileInstaller.installContent was just called")
	}
	callInfo := struct {
		Reader io.Reader
		S      string
		V      os.FileMode
	}{
		Reader: reader,
		S:      s,
		V:      v,
	}
	mock.lockinstallContent.Lock()
	mock.calls.installContent = append(mock.calls.installContent, callInfo)
	mock.lockinstallContent.Unlock()
	return mock.installContentFunc(reader, s, v)
}

// installContentCalls gets all the calls that were made to installContent.
// Check the length with:
//
//	len(mockedfileInstaller.installContentCalls())
func (mock *fileInstallerMock) installContentCalls() []struct {
	Reader io.Reader
	S      string
	V      os.FileMode
} {
	var calls []struct {
		Reader io.Reader
		S      string
		V      os.FileMode
	}
	mock.lockinstallContent.RLock()
	calls = mock.calls.installContent
	mock.lockinstallContent.RUnlock()
	return calls
}

// installFile calls installFileFunc.
func (mock *fileInstallerMock) installFile(s1 string, s2 string) (os.FileMode, error) {
	if mock.installFileFunc == nil {
		panic("fileInstallerMock.installFileFunc: method is nil but fileInstaller.installFile was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
	}{
		S1: s1,
		S2: s2,
	}
	mock.lockinstallFile.Lock()
	mock.calls.installFile = append(mock.calls.installFile, callInfo)
	mock.lockinstallFile.Unlock()
	return mock.installFileFunc(s1, s2)
}

// installFileCalls gets all the calls that were made to installFile.
// Check the length with:
//
//	len(mockedfileInstaller.installFileCalls())
func (mock *fileInstallerMock) installFileCalls() []struct {
	S1 string
	S2 string
} {
	var calls []struct {
		S1 string
		S2 string
	}
	mock.lockinstallFile.RLock()
	calls = mock.calls.installFile
	mock.lockinstallFile.RUnlock()
	return calls
}

// installSymlink calls installSymlinkFunc.
func (mock *fileInstallerMock) installSymlink(s1 string, s2 string) error {
	if mock.installSymlinkFunc == nil {
		panic("fileInstallerMock.installSymlinkFunc: method is nil but fileInstaller.installSymlink was just called")
	}
	callInfo := struct {
		S1 string
		S2 string
	}{
		S1: s1,
		S2: s2,
	}
	mock.lockinstallSymlink.Lock()
	mock.calls.installSymlink = append(mock.calls.installSymlink, callInfo)
	mock.lockinstallSymlink.Unlock()
	return mock.installSymlinkFunc(s1, s2)
}

// installSymlinkCalls gets all the calls that were made to installSymlink.
// Check the length with:
//
//	len(mockedfileInstaller.installSymlinkCalls())
func (mock *fileInstallerMock) installSymlinkCalls() []struct {
	S1 string
	S2 string
} {
	var calls []struct {
		S1 string
		S2 string
	}
	mock.lockinstallSymlink.RLock()
	calls = mock.calls.installSymlink
	mock.lockinstallSymlink.RUnlock()
	return calls
}
