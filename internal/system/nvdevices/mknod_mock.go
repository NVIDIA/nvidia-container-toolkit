// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package nvdevices

import (
	"sync"
)

// Ensure, that mknoderMock does implement mknoder.
// If this is not the case, regenerate this file with moq.
var _ mknoder = &mknoderMock{}

// mknoderMock is a mock implementation of mknoder.
//
//	func TestSomethingThatUsesmknoder(t *testing.T) {
//
//		// make and configure a mocked mknoder
//		mockedmknoder := &mknoderMock{
//			MknodeFunc: func(s string, v1 uint32, v2 uint32) error {
//				panic("mock out the Mknode method")
//			},
//		}
//
//		// use mockedmknoder in code that requires mknoder
//		// and then make assertions.
//
//	}
type mknoderMock struct {
	// MknodeFunc mocks the Mknode method.
	MknodeFunc func(s string, v1 uint32, v2 uint32) error

	// calls tracks calls to the methods.
	calls struct {
		// Mknode holds details about calls to the Mknode method.
		Mknode []struct {
			// S is the s argument value.
			S string
			// V1 is the v1 argument value.
			V1 uint32
			// V2 is the v2 argument value.
			V2 uint32
		}
	}
	lockMknode sync.RWMutex
}

// Mknode calls MknodeFunc.
func (mock *mknoderMock) Mknode(s string, v1 uint32, v2 uint32) error {
	callInfo := struct {
		S  string
		V1 uint32
		V2 uint32
	}{
		S:  s,
		V1: v1,
		V2: v2,
	}
	mock.lockMknode.Lock()
	mock.calls.Mknode = append(mock.calls.Mknode, callInfo)
	mock.lockMknode.Unlock()
	if mock.MknodeFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.MknodeFunc(s, v1, v2)
}

// MknodeCalls gets all the calls that were made to Mknode.
// Check the length with:
//
//	len(mockedmknoder.MknodeCalls())
func (mock *mknoderMock) MknodeCalls() []struct {
	S  string
	V1 uint32
	V2 uint32
} {
	var calls []struct {
		S  string
		V1 uint32
		V2 uint32
	}
	mock.lockMknode.RLock()
	calls = mock.calls.Mknode
	mock.lockMknode.RUnlock()
	return calls
}
